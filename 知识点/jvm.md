## 1、类加载过程

![img](jvm.assets/clip_image002.jpg)

类加载过程

![img](jvm.assets/clip_image004.jpg)

类初始化的时机

 

![img](jvm.assets/clip_image006.jpg)

 

在准备阶段类的静态变量被设置为初始类型的零值。只有在初始化以后才会被设置为期望值，所以读取类的静态变量会导致类初始化并对类变量赋值。而final修饰的常量则是一步到位。详情见深入理解jvm370页。

##  2、JVM结构

![img](jvm.assets/clip_image008.jpg)

## 3、**堆内存结构**

 

![img](jvm.assets/clip_image010.jpg)

将堆分为新生代和老年代，新生代又分为eden区和Survior区

 

## 4、**方法区与永久代的区别？**

方法区是jvm的一种规定，并没有规定如何去实现，仅仅是当时的HotSpot虚拟机设计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。在JDK 6的时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了 ，到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Meta-space）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。

目前，方法区的字符串常量、静态变量数据放在堆中，其他数据放在元空间

![在这里插入图片描述](jvm.assets/clip_image011.png)

## 5、字符串常量、静态变量数据存放区域

java6中所有常量池数据是存放在永久代中，但到java7后 Hostpot 把永久代中的字符串常量、静态变量数据迁移到了堆中，后面的java 8并没有对这部分内容进行迁移，在java8 中字符串常量、静态变量数据还是放到堆中，所以常量池只是在JVM规范定义上属于方法区，但Hotspot在实现的时候部分常量池的内容实际上是保存在堆中了。

##  6、运行时常量池和字符串常量池的存放位置？

JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代。
JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代 。
JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)

## 7、什么是OopMap、安全点？

==oopMap:==GC Roots 枚举的过程中，是需要暂停用户线程的，对栈进行扫描，找到哪些地方存储了对象的引用。然而，栈存储的数据不止是对象的引用，因此对整个栈进行全量扫描，显然是很耗费时间，影响性能的。因此，在 HotSpot 中采取了空间换时间的方法，使用 OopMap 来存储栈上的对象引用的信息。在 GC Roots 枚举时，只需要遍历每个栈桢的 OopMap，通过 OopMap 存储的信息，快捷地找到 GC Roots。

==安全点：==如果每一条指令的执行，都生成（或更新）对应的OopMap，那么将会占用大量的内存空间，增加了 GC 的空间成本。Safe Point 就是一个安全点，可以理解为用户线程执行过程中的一些特殊位置。线程执行到 Safe Point 的时候，OopMap 保存了当前线程的上下文，当线程执行到这些位置的时候，说明线程当前的状态是确定的，线程有哪些对象、使用了哪些内存。

推荐阅读 https://zhuanlan.zhihu.com/p/441867302